const t = window.Reflect, {get: e, has: n, set: o} = t;

if ("object" != typeof (r = window.customElements) || null === r) throw new TypeError(" customElements  not supported !");

var r;

window.CustomElementRegistry = t.get(window.customElements, "constructor");

const i = Symbol.for("elementmap"), {CustomElementRegistry: l} = window, s = window.customElements;

n(s, i) || o(s, i, Object.create(null));

const c = (t, e) => a(t, e);

function a(t, n, o = 1) {
    if (!function(t) {
        return !!("function" == typeof t && t.prototype && t.prototype instanceof HTMLElement);
    }(t)) throw TypeError("invalid custom element class !");
    if (Object.values(s[i]).includes(t)) return function(t, e) {
        const n = Object.entries(t).find((t => t[1] === e));
        return n ? n[0] : void 0;
    }(e(s, i), t);
    {
        const r = function(t = 1) {
            return Array(t).fill(void 0).map((() => e(f, Math.floor(Math.random() * f.length)))).join("") + "-" + Array(t).fill(void 0).map((() => e(u, Math.floor(Math.random() * u.length)))).join("");
        }(o);
        return s.get(r) ? a(t, n, o + 1) : (n ? s.define(r, t, {
            extends: n
        }) : s.define(r, t), r);
    }
}

s.define = function(t, e, n) {
    l.prototype.define.call(s, t, e, n), s[i][t] = e;
};

const f = Array(26).fill(void 0).map(((t, e) => 97 + e)).map((t => String.fromCharCode(t))), m = Array(16).fill(void 0).map(((t, e) => e)).map((t => t.toString(16))), u = [ ...new Set([ ...m, ...f ]) ];

export { c as default };
//# sourceMappingURL=index.min.js.map
